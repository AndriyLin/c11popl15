"C11"

(*
 * Translation of C11 memory model from "Common Compiler Optimisations are
 * Invalid in the C11 Memory Model and what we can do about it' (POPL '15)
 *)

include "library.cat"

(* Simple aliases *)
let sb = singlestep(po) (* except po is a total per-thread order *)
let mo = co
let C = rmw

(* --------------------------------------------------------------------------*)
(* Figure 2: Auxiliary definitions                                           *)
(* --------------------------------------------------------------------------*)
(* In the paper isX is a predicate; here it is the set satisfying X *)
let isread = R | C
let iswrite = W | C
let isfence = F & (acq | rel) (* herd allows fences of other memory orders *)
let sameThread = int(( _ * _ )) (* built-in relation *)
let isaccess = isread | iswrite
let isrmw = isread & iswrite (* i.e., equal to C *)
let isNA = na
let isSC = sc
let isAcq = acq | acq_rel | sc
let isRel = rel | acq_rel | sc

(* rsElem gives possible candidates for the release sequence *)
let rsElem = sameThread | ( _ * isrmw )
(* capture the case where a pair of sequenced mo steps are not matched with rsElem *)
let intermediateMOStepNotInRSElem = (~rsElem & mo); mo
let rseq = (rsElem & mo & ~( intermediateMOStepNotInRSElem ))?

(* Synchronises with case-split (not used) *)
(* a = c and b = d *)
let swCase1 = rseq; rf
(* a = Fence and b = d *)
let swCase2 = (( isfence * _ ) & sb+); rseq; rf
(* a = c and b = Fence *)
let swCase3 = rseq; rf; (sb+ & ( _ * isfence ))
(* a = Fence and b = Fence *)
let swCase4 = (( isfence * _ ) & sb+); rseq; rf; (sb+ & ( _ * isfence ))

(* Instead we use a generalised relation equivalent to 
   (swCase1 | swCase2 | swCase3 | swCase4 ) *)
let fenceSB = ( isfence * _ ) & sb+
let sbFence = sb+ & ( _ * isfence )
(* The ?s capture the disjunctions of the original case split *)
let swDisj = (fenceSB)?; rseq; rf; (sbFence)?
(* NB: The Coq formalisation of the paper has additional constraints on the
   writes in the release sequence being non-atomic *)

let sw = ~sameThread
       & ( isRel * _     )
       & ( _     * isAcq )
       & swDisj

let hb = (sb | sw | asw)+

let racy = ( isaccess * _ )
         & ( _ * isaccess )
         & loc (* loc(a) = loc(b) *)
         & ~id (* a != b *)
         & (( iswrite * _ ) | ( _ * iswrite ))
         & (( isNA * _ ) | ( _ * isNA ))
         & ~hb & ~(hb^-1)
         & ~sameThread (*< NB: this restriction is not included in the *)
                       (*<     paper's model; raise this with Viktor.  *)

(* undefined_unless empty racy as Racy *)

(* --------------------------------------------------------------------------*)
(* Figure 5: Axioms                                                          *)
(* --------------------------------------------------------------------------*)

(* In the paper, `sc' is a total order over all SC atomics. We build a partial
   order `preSC' such that all linearisations of preSC are instances of the
   total sc order of C11 *)
let preSC = (hb | mo) &  ( isSC * isSC )

(* 1. ConsSB satisfied due to construction of po (aliased to sb) *)

(* 2. ConsMO satisfied due to construction of co (aliased to mo) *)

(* 3. ConsSC *)
acyclic preSC as ConsSC (* inclusion of hb and mo by construction of preSC *)

(* 4. ConsRFdom satisfied due to how herd builds rf for C11 *)
(* herd does not build rf for uninitialised reads (NB: double-check this) *)

(* 5. ConsRF satisfied due to construction of rf *)

(* 6. ConsRFna *)
let lhsConsRFna = rf & (( isNA * _ ) | ( _ * isNA ))
call subseteq (rf & (( isNA * _ ) | ( _ * isNA )), hb) (* as ConsRFna *)
(* NB: Tyler conjectures that empty racy and ConsRFhb implies ConsRFna *)

(* 7. SCReads *)
(* partial order preSCR mirroring scr in paper *)
let preSCR = preSC & ( iswrite * _ ) & loc
let imm = singlestep
let lhsSCReads = rf & ( _ * isSC )
let rhsSCReads = imm(preSCR)
               | (( (!isSC) * _ ) & nodetour(rf, hb, imm(preSCR)))
call subseteq(lhsSCReads, rhsSCReads) (* as SCReads *)
(* Implication turned into subseteq *)
(* NB: is this problematic because preSCR is not total? *)

(* 8. IrrHB *)
irreflexive hb as IrrHB

(* 9. ConsRFhb *)
irreflexive (rf;hb) as ConsRFhb

(* 10-13. Coherence *)
irreflexive (hb;mo) as CohWW
irreflexive (fr;rf;hb) as CohRR (* fr == rf^-1; mo *)
irreflexive (fr;hb) as CohWR
irreflexive (rf;hb;mo) as CohRW

(* 14. AtRMW *)
irreflexive ((fr & ( isrmw * _ )) ; mo) as AtRMW

(* 15. ConsAlloc not modelled because we cannot express malloc *)

(*
(* --------------------------------------------------------------------------*)
(* Section 4: Proposed Fixes                                                 *)
(* --------------------------------------------------------------------------*)

(* 4.1 Resolving causality cycles *)

(* Naive *)
(* drop ConsRFna *)

(* Arf *)
(*
acyclic (hb | rf) as Arf
*)

(* Arfna *)
(*
let rfNA = rf & (( isNA * _ ) | ( _ * isNA ))
acyclic (hb | rfNA) as Arfna
 *)

(* 4.2 Correcting the SCReads axiom *)

(* SCRead' *)
let rhsSCReads' = imm preSCR
                | (( (!isSC) * _ ) & (nodetour rf hb preSCR))
call subseteq(lhsSCReads, rhsSCReads2) (* as SCReads' *)

(* 4.3 Strengthening the Release Sequence definition *)
(* NB: revisit how to express the third conjunct
let rec rseq' = id
              | (sameThread & mo)
              | (( in rseq' * isrmw ))
*)

(* 4.4 Allowing intra-thread synchronisation *)
let sameThread' = sb+
(* NB: is this vacuously the same as our original sameThread because of po? *)

(* --------------------------------------------------------------------------*)
(* Section 5                                                                 *)
(* --------------------------------------------------------------------------*)

(* Redundant axiom equivalent to CohWW *)
call subseteq(hb & ( iswrite * iswrite ) & loc, mo) (* as ConsMOhb *)

(* Alternative presentation of Coherence *)
let rb =  fr (* fr == rf^-1; mo *)
       & ~id (* a != b *)
let com = mo | rf | rb
acyclic ((hb & loc) | com) as Coh
*)

undefined_unless empty racy as Racy
